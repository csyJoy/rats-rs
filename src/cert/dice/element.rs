use super::HashAlgo;
use crate::{attester::GenericEvidence, errors::*};

use ciborium::Value;
use serde::{Deserialize, Deserializer, Serialize, Serializer};

use std::collections::HashMap;

/// Intel TEE quote, including all SGX (both EPID and ECDSA) and TDX (ECDSA) quote types
pub const OCBR_TAG_EVIDENCE_INTEL_TEE_QUOTE: u64 = 60000;
/// Intel TEE report (TDX report or SGX report type 2)
pub const OCBR_TAG_EVIDENCE_INTEL_TEE_REPORT: u64 = 60001;
/// SGX report (legacy, generated by EREPORT)
pub const OCBR_TAG_EVIDENCE_INTEL_SGX_LEGACY_REPORT: u64 = 60002;
pub const OCBR_TAG_EVIDENCE_SEV_SNP: u64 = 0x1a7504;
pub const OCBR_TAG_EVIDENCE_SEV: u64 = 0x1a7505;
pub const OCBR_TAG_EVIDENCE_CSV: u64 = 0x1a7506;

pub type HashAlgoIanaId = u8;

impl TryFrom<HashAlgoIanaId> for HashAlgo {
    type Error = Error;

    fn try_from(value: HashAlgoIanaId) -> Result<Self> {
        Ok(match value {
            1 => Self::Sha256,
            7 => Self::Sha384,
            8 => Self::Sha512,
            _ => Err(Error::kind_with_msg(
                ErrorKind::Unsupported,
                format!("unsupported hash-alg-id: {}", value),
            ))?,
        })
    }
}
impl Into<HashAlgoIanaId> for HashAlgo {
    fn into(self) -> HashAlgoIanaId {
        match self {
            HashAlgo::Sha256 => 1,
            HashAlgo::Sha384 => 7,
            HashAlgo::Sha512 => 8,
        }
    }
}

/// An definite-length encoded tagged CBOR array with two entries.
///  For SGX / TDX ECDSA evidence, it is: definite-length encoded tagged CBOR array with two entries, holding TEE quote and serialized custom claims:
///     60000([ TEE_ECDSA_quote(claims-buffer-hash), claims-buffer ])
#[derive(PartialEq, Debug)]
struct TaggedEvidenceBufferHelper<'a> {
    tag: u64,                /* a tag for distinguishing evidence type */
    evidence: &'a [u8],      /* shall be serialized to cbor byte string */
    claims_buffer: &'a [u8], /* shall be serialized to cbor byte string */
}

impl<'a> Serialize for TaggedEvidenceBufferHelper<'a> {
    fn serialize<S: Serializer>(&self, s: S) -> std::result::Result<S::Ok, S::Error> {
        Value::Tag(
            self.tag,
            Box::new(Value::Array(vec![
                Value::Bytes(self.evidence.into()),
                Value::Bytes(self.claims_buffer.into()),
            ])),
        )
        .serialize(s)
    }
}

// impl<'de> Deserialize<'de> for TaggedEvidenceBuffer {
//     fn deserialize<D: Deserializer<'de>>(deserializer: D) -> std::result::Result<Self, D::Error> {
//         let tagged = Value::deserialize(deserializer)?;
//         match tagged {
//             Value::Tag(tag, any) => match &any {
//                 Value::Array(a) => {
//                     a.len() == 2
//                 }
//                 _ => Err(serde::de::Error::invalid_type((&tagged).into(), &"array")),
//             },
//             _ => Err(serde::de::Error::invalid_type((&tagged).into(), &"tag")),
//         }
//     }
// }

pub fn generate_evidence_buffer_with_tag<E: GenericEvidence>(
    evidence: &E,
    claims_buffer: &[u8],
) -> Result<Vec<u8>> {
    let helper = TaggedEvidenceBufferHelper {
        tag: E::DICE_OCBR_TAG,
        evidence: evidence.get_raw_evidence(),
        claims_buffer: claims_buffer,
    };
    let mut res = vec![];
    ciborium::into_writer(&helper, &mut res)?;
    Ok(res)
}

// TODO: endorsement buffer

pub type Claims = HashMap<String, Vec<u8>>;

/// claims-buffer is a byte string of definite-length encoded CBOR map of one or two custom claims, with each claim name in text string format, and its value in byte string format.
struct ClaimsHelper<'a>(&'a Claims);

impl<'a> Serialize for ClaimsHelper<'a> {
    fn serialize<S: Serializer>(&self, s: S) -> std::result::Result<S::Ok, S::Error> {
        let v = self
            .0
            .iter()
            .map(|claim| (Value::Text(claim.0.clone()), Value::Bytes(claim.1.clone())))
            .collect::<Vec<_>>();
        Value::Map(v).serialize(s)
    }
}

pub fn generate_claims_buffer(claims: &Claims) -> Result<Vec<u8>> {
    let mut res = vec![];
    ciborium::into_writer(&ClaimsHelper(claims), &mut res)?;
    Ok(res)
}

pub fn generate_pubkey_hash_value_buffer(hash_algo: HashAlgo, hash: &[u8]) -> Result<Vec<u8>> {
    let mut res = vec![];
    ciborium::into_writer(
        &(
            Into::<HashAlgoIanaId>::into(hash_algo),
            serde_bytes::Bytes::new(hash),
        ),
        &mut res,
    )?;
    Ok(res)
}

#[cfg(test)]
pub mod tests {

    use super::*;

    #[test]
    fn test_generate_claims_buffer() -> Result<()> {
        let mut expected = Claims::new();
        expected.insert("key1".into(), "value1".into());
        expected.insert("key2".into(), "value2".into());

        let cbor = generate_claims_buffer(&expected)?;
        println!("claims buffer in cbor: {}", hex::encode(&cbor));
        let deserialized = ciborium::from_reader(cbor.as_slice())?;
        assert_eq!(expected, deserialized);
        Ok(())
    }

    #[test]
    fn test_generate_pubkey_hash_value_buffer() -> Result<()> {
        let cbor = generate_pubkey_hash_value_buffer(HashAlgo::Sha256, b"\x00\x01\x02\x03")?;
        println!(
            "claims pubkey_hash_value_buffer in cbor: {}",
            hex::encode(&cbor)
        );
        assert_eq!(cbor, hex::decode("82014400010203")?);
        Ok(())
    }
}
